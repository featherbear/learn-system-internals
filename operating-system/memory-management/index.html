<!doctype html><html lang=en><head><meta charset=utf-8><title>Memory Management</title><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black-translucent><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=../../reveal-js/css/reset.css><link rel=stylesheet href=../../reveal-js/css/reveal.css><link rel=stylesheet href=../../reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=../../highlight-js/default.min.css></head><body><div class=reveal><div class=slides><section data-noprocess data-shortcode-slide class=center><h2 id=memory-management>Memory Management</h2></section><section><h2 id=memory-management-1>Memory Management</h2><p>As covered in <a href=../../cpu-fundamentals/memory/#/4>CPU Fundamentals</a>, registers are very fast but very limited in capacity, whereas secondary storage devices (i.e. a hard disk) hold large amounts of data at the expense of speed</p><ul><li>Registers - ~1 ns.</li><li>Caches - ~2 ns.</li><li>Main memory (RAM) - ~10 ns.</li><li>Magnetic disks - ~10 ms.</li></ul><p><u><strong>Principle of Locality</strong></u><br>Things closer to each other are faster</p></section><section><h2 id=program-memory-binds>Program Memory Binds</h2><section data-shortcode-section><blockquote><p>Before a program is executed, it is loaded into memory</p></blockquote><p>During program compilation, various addresses are hardcoded into the program - but there is no guarantee that those addresses are available or exist</p></section><section><p><u><strong>Idea 1</strong></u><br>When a program is loaded into memory, the addresses in the program could be overwritten to match the new memory addresses, but it is slow and complicated.</p><p><u><strong>Idea 2</strong></u><br>Monitor every memory address request, and add an offset to each address - such that each address exists within the computer memory. However offsets will have to be very well managed and calculated.</p></section></section><section><h2 id=virtual-memory>Virtual Memory</h2><p>The concept of virtual memory serves as a solution to several of these program memory concerns</p><ul><li>Arbitrary memory addresses can be used</li><li>The same memory address can be used between processes</li><li>The same memory region can be shared between processes</li><li>Assigned memory does not need to be physically contiguous</li></ul></section><section><p><img src=virtual-memory.png alt></p><p>Inside the CPU is a Memory Management Unit (MMU).</p><p>This hardware device manages and coordinates access to memory addresses in the system; such as translating virtual memory addresses into physical memory addresses.</p></section><section><h2 id=page-tables>Page Tables</h2><section data-shortcode-section><pre><code class=language-text>                        0x00000 +----------+
                                | frame 0  |
                                +----------+
                                | frame 1  |
                                +----------+
        Computer memory ===&gt;    | frame 2  |
                                +----------+
                                | frame 3  |
                                +----------+
                                |   ....   |
                        0x..... +----------+
</code></pre><p>The computer&rsquo;s physical memory is partitioned into blocks of (generally) fixed sizes, each known as a frame. Commonly the frame size is 4 KB.</p></section><section><pre><code class=language-text>            Page Table                 Memory
            +--------+              +----------+ 0x00000
            | page 0 |+------------&gt;| frame 0  |
            +--------+              +----------+
            | page 1 |+------+     &gt;| frame 1  |
            +--------+        \   / +----------+
            | page 2 |+----------+  | frame 2  |
            +--------+          \   +----------+
            | page 3 |           \  | frame 3  |
            +--------+            \ +----------+
            | page 4 |             &gt;| frame 4  |
            +--------+              +----------+ 0x.....
</code></pre><p>A page table is a mapping of pages to frames.<br>i.e <u><code>page 2</code></u> will map to <u><code>frame 1</code></u></p></section><section><pre><code class=language-text>            Page Table                 Memory
            +--------+              +----------+ 0x00000
            | page 0 |+------------&gt;| frame 0  |
            +--------+              +----------+
            | page 1 |+------+     &gt;| frame 1  |
            +--------+        \   / +----------+
            | page 2 |+----------+  | frame 2  |
            +--------+          \   +----------+
            | page 3 |           \  | frame 3  |
            +--------+            \ +----------+
            | page 4 |             &gt;| frame 4  |
            +--------+              +----------+ 0x.....
</code></pre><p>Page tables remove the requirement for a process to need a contiguous space of memory, which can be difficult to allocate with lots of programs running.</p></section><section><h3 id=notes>Notes</h3><ul><li><p>Each process has their own page table, which allows the same memory address &lsquo;value&rsquo; / page number to be mapped to a different physical memory frame.</p></li><li><p><code>PAGE_SIZE == FRAME_SIZE</code></p></li></ul></section></section><section><h2 id=page-table-translation>Page Table Translation</h2><section data-shortcode-section><p><code>vaddr -&gt; MMU -&gt; paddr</code></p><p>When a virtual address is requested by a process, the MMU performs a page table lookup</p><pre><code class=language-c>/******************* C/C++ pseudocode **********************/

#define FRAME_SIZE 4096
#define PAGE_SIZE  PAGE_SIZE

pageNumber   = vaddr / PAGE_SIZE;        // Page number
offset       = vaddr % PAGE_SIZE;        // Address offset
frameNumber  = pageTable[pageNumber];    // Frame number
frameAddress = frameNumber * FRAME_SIZE; // Frame address
paddr        = frameAddress + offset     // Physcal address

// paddr = pageTable[memoryAddress / PAGE_SIZE] * FRAME_SIZE 
//         + memoryAddress % PAGE_SIZE
</code></pre></section><section><p>Hardware wise, this process is efficient and does not require modulo and division operations</p><p>With a page size of 4 KB, there are $2^{12}$ (4096) values.</p><p><em>In a 32-bit address space, the last 12 LSB bits are used for the offset, and the first 20 MSB bits are used as the page number</em></p><pre><code>Requested Address: 0x08041234
      addr &gt;&gt; 12          addr &amp; 0xFFF
      1000000001000001    001000110100
      Page: 32833         Offset: 0x234
</code></pre></section><section><p><img src=https://featherbear.cc/UNSW-COMP3231/post/assignment-3/Screenshot%20from%202020-04-15%2018-45-38.png alt></p></section></section><section><h2 id=double-page-tables>Double Page Tables</h2><section data-shortcode-section><p>A page table needs to have enough entries to cover the physical address space -&gt; $ \frac{memory}{frame\ size} $</p><p><em>i.e. with a 32-bit address space, a page table will contain $\frac{2^{32}}{2^{12}} = 2^{20}$ entries</em></p><p>If each entry was roughly 2 bytes (ie a <code>short</code> - 16 bits), the page table will be 2 MB in size; regardless of the number of pages mapped.</p><p><u>Remember</u> - each process has its own page table. 500 process will require 1GB just for the page table!</p></section><section><p>A way to reduce this memory overhead is to introduce a second level of page tables that are only allocated if required.</p><p><img src=https://web.cs.ucla.edu/classes/spring13/cs111/scribe/15b/2-level_page_table.jpg alt></p></section><section><p><img src=https://web.cs.ucla.edu/classes/spring13/cs111/scribe/15b/2-level_page_table.jpg alt></p><p>In the case of a 2-level 10-10 bit page table, the first level PT contains addresses of second-level PTs</p></section><section><p><img src=https://web.cs.ucla.edu/classes/spring13/cs111/scribe/15b/2-level_page_table.jpg alt></p><p>Therefore only $2^{10} \times 2\ (short)$ bytes are required.<br>2 KB per process (initially)!</p></section></section><section><h2 id=the-tlb>The TLB</h2><section data-shortcode-section><p>Inside the MMU, the <em>Translation Lookaside Buffer</em> is a hardware cache of the last used page table entries.<br>As the MMU receives a requested virtual memory address, the TLB cache is accessed.</p><ul><li>If a valid entry for the requested memory address exists, it is returned.<br></li><li>Otherwise, a &ldquo;TLB Miss&rdquo; occurs - which signals the MMU to perform a &ldquo;TLB Refill&rdquo;</li></ul></section><section><p>As the TLB is a hardware implementation, its entries are global for all processes - so metadata is required to keep track of which entry is for which process.</p><ul><li>The TLB stores page table entries rather than entire memory addresses with their offsets.<br></li><li>In a 32-bit memory address with a 4096 byte page size (12 bit space), the last 12 LSB bits can be used to store these metadata (i.e. process ID, global flag)</li></ul></section></section><section><h3 id=tlb-refill>TLB Refill</h3><p>When a TLB Refill occurs, the MMU performs a <a href=#/6>page table lookup</a> to find the correct page and frame.</p><p>If a page has not been accessed before, a frame will be allocated, and the page will be mapped to that frame.</p><p>An entry will then be stored in the TLB, containing the requested page, the resolved frame, and the process metadata. If the TLB is full, an entry is replaced (either by random, or by last-recently-used)</p><p>Note: Several pages <em>can</em> map to the same frame</p></section><section><h2 id=swapping>Swapping</h2><p>When the RAM is full, and more memory is needed, the computer can use space on secondary storage (i.e. from an SSD) as a RAM storage location. However, as secondary storage is logically further away from the CPU, it will be much slower.</p><p>Regardless, it allows for the memory of inactive processes to be stored off-RAM, to create more space for new/active processes that request for memory.</p></section><section><h2 id=recap>Recap</h2><ul><li>Arbitrary memory addresses can be used</li><li>The same memory address can be used between processes</li><li>The same memory region can be shared between processes</li><li>Assigned memory does not need to be physically contiguous</li><li>Program memory can exist outside of the RAM</li></ul></section><section><h2 id=os-161-memory>OS/161 Memory</h2><p><img src=https://featherbear.cc/UNSW-COMP3231/post/assignment-3/sketch.png alt></p></section></div></div><script type=text/javascript src=../../reveal-hugo/object-assign.js></script><a href=../../reveal-js/css/print/ id=print-location style=display:none></a><script type=text/javascript>var printLocationElement=document.getElementById('print-location');var link=document.createElement('link');link.rel='stylesheet';link.type='text/css';link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?'pdf.css':'paper.css');document.getElementsByTagName('head')[0].appendChild(link);</script><script type=application/json id=reveal-hugo-site-params>{"center":false,"history":true,"pdf_separate_fragments":false,"slide_number":true}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=../../reveal-js/js/reveal.js></script><script type=text/javascript>function camelize(map){if(map){Object.keys(map).forEach(function(k){newK=k.replace(/(\_\w)/g,function(m){return m[1].toUpperCase()});if(newK!=k){map[newK]=map[k];delete map[k];}});}
return map;}
var revealHugoDefaults={center:true,controls:true,history:true,progress:true,transition:"slide"};var revealHugoSiteParams=JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);var revealHugoPageParams=JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);var options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options);</script><script type=text/javascript src=../../reveal-js/plugin/markdown/marked.js></script><script type=text/javascript src=../../reveal-js/plugin/markdown/markdown.js></script><script type=text/javascript src=../../reveal-js/plugin/highlight/highlight.js></script><script type=text/javascript src=../../reveal-js/plugin/zoom-js/zoom.js></script><script type=text/javascript src=../../reveal-js/plugin/notes/notes.js></script><script type=text/javascript>document.title+=" | Learn System Internals";window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>if(window.location.search.match(/\?print-pdf/gi)){function insertCSS(src){const link=document.createElement('link');link.rel='stylesheet';link.type='text/css';link.href=src;document.getElementsByTagName('head')[0].appendChild(link);}
insertCSS('\/reveal-js\/css\/print\/pdf.css');insertCSS('\/hideHomeButton.css');}</script><a id=homeButton style=position:fixed;bottom:8px;left:8px;z-index:31;font-family:Helvetica,sans-serif;font-size:12px;line-height:1;color:#fff;background-color:rgba(0,0,0,.4);padding:5px;text-decoration:none href=../../>Home</a></body></html>