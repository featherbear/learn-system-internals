<!doctype html><html lang=en><head><meta charset=utf-8><title>Memory</title><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black-translucent><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=../../reveal-js/css/reset.css><link rel=stylesheet href=../../reveal-js/css/reveal.css><link rel=stylesheet href=../../reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=../../highlight-js/default.min.css></head><body><div class=reveal><div class=slides><section data-noprocess data-shortcode-slide class=center><h1 id=memory>Memory</h1></section><section><h2 id=everything-is-memory>Everything is Memory</h2><span class=fragment><p>When we save a file, it is saved to the computer memory.</p></span><span class=fragment><p>When we perform an arithmetic operation, its operands and outputs are stored in the memory</p></span><span class=fragment><p>When we press a key, a flag in the memory is changed.</p></span><span class=fragment><p>When we launch a program, that program is loaded into memory!</p></span></section><section><h2 id=representation-of-data>Representation of Data</h2><section data-shortcode-section><p>As digital circuits (i.e. computers) only deal with binary data (1s and 0s) - there exists different <em>encoding schemas</em> to represent different data types.</p></section><section><h3 id=ascii>ASCII</h3><p>ASCII is a representation of the common characters used throughout the world (i.e the keys on your keyboard)</p><p><img src=http://www.asciitable.com/index/asciifull.gif alt></p></section><section><h3 id=positive-integers>Positive Integers</h3><p>Positive integers are represented as their binary representation - bound to the data type assigned</p><p>i.e. the byte <code>81 == 0b01010001</code></p></section><section><h3 id=negative-integers>Negative Integers</h3><p>Negative integers are represented as the two&rsquo;s complement of their binary representation.</p><blockquote><p>- Two&rsquo;s Complement -<br>Invert the bits, and add <code>1</code>.</p></blockquote><pre><code>(byte)  81 ==  0b01010001
(byte) -81 == ~0b01010001 + 1
           ==  0b10101110
                      + 1
           ==  0b10101111     &lt;--- Two's complement of 81
</code></pre></section><section><h3 id=negative-integers-1>Negative Integers</h3><p>Given the representation of the byte <code>81</code></p><ul><li>(byte) <code>81 == 0b01010001</code></li><li>(byte) <code>-81 == 0b10101111</code></li></ul><p>We can verify two&rsquo;s complement works by adding both binary numbers together (ie <code>81 + -81 = 0</code>)</p><p>(byte) <code>0b01010001 + 0b10101111 = 0</code></p></section><section><h3 id=floating-point-numbers>Floating Point Numbers</h3><p>Floating Point numbers (i.e. 103.121369126) are represented by the <code>IEEE 754</code> standard.</p><p>The decimal part of a floating point number is represented as the sum of negative powers of 2</p><p>i.e. 0.75 = $\frac{1}{2}$ + $\frac{1}{4}$</p></section><section><h3 id=floating-point-numbers-1>Floating Point Numbers</h3><p>There exists a single and double precision variant.</p><table><thead><tr><th align=center>Single Precision</th><th align=center>Double Precision</th></tr></thead><tbody><tr><td align=center>First bit - sign<br>Next 8 bits - exponent<br>Next 23 bits - fraction</td><td align=center>First bit - sign<br>Next 11 bits - exponent<br>Next 52 bits - fraction</td></tr></tbody></table></section><section><h3 id=floating-point-numbers-2>Floating Point Numbers</h3><h4 id=floating-point-to-ieee-754>Floating Point to IEEE 754</h4><p>1) Convert the floating point number into binary, keeping the decimal<br>2) Turn the floating point number into its scientific form (one digit on the left of the decimal)<br>3) Convert the exponent into its binary representation and add it to a bias value ($ 2^n -1 $)<br>4) Answer is (sign)(exponent+bias)(fraction)</p></section><section><h3 id=floating-point-numbers-3>Floating Point Numbers</h3><h4 id=ieee-754-to-floating-point>IEEE 754 to Floating Point</h4><p>1) Note the sign of the value<br>2) Subtract the bias ($ 2^n -1 $) from the exponent<br>3) Assemble the floating point 1.(fraction)<br>4) Shift the decimal place by the value from (2)</p></section></section><section><h2 id=endian-ness>Endian-ness</h2><section data-shortcode-section><p>Multi-byte values (i.e. values greater than 255) can be stored to the memory in two different ways.</p><ul><li>Big Endian - The MSB (most significant byte) is first<ul><li>i.e. The number <code>287</code> is stored as <code>\x01\x1f</code></li></ul></li><li>Little Endian - The LSB (least significant byte) is first<ul><li>i.e. The number <code>287</code> is stored as <code>\x1f\x01</code></li></ul></li></ul></section><section><h3 id=uses>Uses</h3><p>Most systems use the Little Endian address order, due to its inherent properties</p><ul><li>e.g faster operations<ul><li>Checking if an <code>int</code> (4 bytes) at <code>0x11223344</code> is even, only that address needs to be checked</li><li>If Big Endian is used, the CPU will need to calculate and then check <code>0x11223347</code></li></ul></li></ul></section><section><h3 id=uses-1>Uses</h3><p>Most systems use the Little Endian address order, due to its inherent properties</p><ul><li>e.g type casting<ul><li>Casting an <code>int</code> (4 bytes) to a <code>char</code> (1 byte) is trivial, as the LSB is already at the right address</li></ul></li></ul><blockquote><p>The only common modern-day use for Big Endian is for storing strings</p></blockquote></section></section><section><h2 id=ram>RAM</h2><p>Random Access Memory is a form of computer memory that allows data to be quickly written and read. They are (relatively) cheap, and complement the CPU registers by holding large amounts of data that is frequently accessed.</p><p>It is called Primary Storage - as it is connected directly to the CPU. Secondary storage devices (i.e. hard disks) are connected indirectly.</p><p>RAM is considered volatile / non-persistent memory - data is only kept when the RAM is powered on.</p></section><section><h2 id=registers-vs-ram>Registers vs RAM</h2><table><thead><tr><th align=left></th><th align=center>Registers</th><th align=center>Primary Storage (RAM)</th><th align=center>Secondary Storage (SSD/HDD)</th></tr></thead><tbody><tr><td align=left>Location</td><td align=center>CPU</td><td align=center>On-board</td><td align=center>External</td></tr><tr><td align=left>Speed</td><td align=center>Fast</td><td align=center>Slow</td><td align=center>Slower</td></tr><tr><td align=left>Price</td><td align=center>-</td><td align=center>$$</td><td align=center>$</td></tr><tr><td align=left>Capacity</td><td align=center>bytes</td><td align=center>gigabytes</td><td align=center><em>a lot</em></td></tr></tbody></table><p><strong><em>Registers are fast but they cannot store a lot of data!</em></strong></p></section><section><h2 id=memory-mapped-i-o>Memory Mapped I/O</h2><p>Both registers and RAM modules store data, however due to their different locations - they are accessed in different ways.</p><p>Some CPU architectures allow &ldquo;Memory Mapped IO&rdquo; operation, which can map various I/O devices (including registers!) to virtual locations in the memory.</p><p>Therefore, the access methods to register data and RAM data can be unified, making interoperability better.</p></section><section><h2 id=port-mapped-i-o>Port Mapped I/O</h2><p>Like memory mapped I/O, output ports of devices in a system can also be mapped to virtual addresses in the memory</p></section><section><h2 id=memory-layout>Memory Layout</h2><p><img src=https://i.stack.imgur.com/oETv1.jpg alt></p><p>As mentioned earlier, when a program is executed, its instructions are copied into the memory.<br>By standard, the instructions are loaded near the start (lower portion) of the available memory space.</p></section><section><h3 id=stack>Stack</h3><section data-shortcode-section><p>The <em>stack</em> contains the temporary memory and data used by the functions of a program, and is located near the top of the memory address space.</p><p>It is called a stack due to how it is accessed.</p><ul><li>When a function is called a <strong>stack frame</strong> is created and appended to the end of the stack.</li><li>When that function exits, its stack frame is removed from the stack frame.</li></ul></section><section><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Call_stack_layout.svg/513px-Call_stack_layout.svg.png alt></p></section><section><p>The stack contains the parameters and temporary variables that a function will use to complete its execution.</p><p>The stack also contains data related to what the CPU should do after the function finishes, such as values of the CPU registers prior to the function being called.</p><p>This includes the &ldquo;return address&rdquo; that the CPU will go to after the function is finished.</p></section></section><section><h3 id=heap>Heap</h3><p>The heap contains long-life data that persists during the lifetime of the program (rather than the lifetime of an instance of a specific function).</p><p>This memory space can be considered as the &lsquo;global scope&rsquo; region, where all functions can access the data in the heap</p><p>The heap is located after the text region of the memory (where the program instructions are loaded) - i.e. near the start of the memory address space.</p></section><section><h2 id=memory-allocation-in-c>Memory Allocation (in C)</h2></section></div></div><script type=text/javascript src=../../reveal-hugo/object-assign.js></script><a href=../../reveal-js/css/print/ id=print-location style=display:none></a><script type=text/javascript>var printLocationElement=document.getElementById('print-location');var link=document.createElement('link');link.rel='stylesheet';link.type='text/css';link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?'pdf.css':'paper.css');document.getElementsByTagName('head')[0].appendChild(link);</script><script type=application/json id=reveal-hugo-site-params>{"center":false,"history":true,"pdf_separate_fragments":false,"slide_number":true}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=../../reveal-js/js/reveal.js></script><script type=text/javascript>function camelize(map){if(map){Object.keys(map).forEach(function(k){newK=k.replace(/(\_\w)/g,function(m){return m[1].toUpperCase()});if(newK!=k){map[newK]=map[k];delete map[k];}});}
return map;}
var revealHugoDefaults={center:true,controls:true,history:true,progress:true,transition:"slide"};var revealHugoSiteParams=JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);var revealHugoPageParams=JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);var options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options);</script><script type=text/javascript src=../../reveal-js/plugin/markdown/marked.js></script><script type=text/javascript src=../../reveal-js/plugin/markdown/markdown.js></script><script type=text/javascript src=../../reveal-js/plugin/highlight/highlight.js></script><script type=text/javascript src=../../reveal-js/plugin/zoom-js/zoom.js></script><script type=text/javascript src=../../reveal-js/plugin/notes/notes.js></script><script type=text/javascript>document.title+=" | Learn System Internals";window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script>if(window.location.search.match(/print-pdf/gi)){var link=document.createElement('link');link.rel='stylesheet';link.type='text/css';link.href='reveal.js/css/print/pdf.css';document.getElementsByTagName('head')[0].appendChild(link);}</script></body></html>