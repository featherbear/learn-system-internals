<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Learn System Internals</title><link>/</link><description>Recent content on Learn System Internals</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><lastBuildDate>Tue, 01 Sep 2020 13:14:43 +1000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Time Management</title><link>/operating-system/time-management/</link><pubDate>Tue, 01 Sep 2020 13:14:43 +1000</pubDate><guid>/operating-system/time-management/</guid><description>Time Management Access Management A processor can only run one thing at a time.
This include the OS itself.
Application is running - OS paused
OS running - application paused
However this does not feel apparent (perceived performance) as regular interrupts (i.e. timers, interrupts) cause the processor to continually switch between applications and the OS.
If the CPU did not switch between the different applications, future applications must wait for the termination of previous tasks.</description></item><item><title>Access Management</title><link>/operating-system/access-management/</link><pubDate>Tue, 01 Sep 2020 13:14:40 +1000</pubDate><guid>/operating-system/access-management/</guid><description>Access Management Processer Privilege Levels Some microprocessors are designed to operate under different privilege levels.
In User / Application Mode, resources such as devices, registers, certain memory regions and certain CPU instructions are restricted.
In Kernel / Privileged Mode, full access to resources and CPU instructions are permitted.
On such systems, the kernel runs in privileged mode, whilst most other applications run in user mode.
If an application running inside user mode attempts to access a restricted memory region, or attempts to execute a restricted CPU instruction, the request will be denied.</description></item><item><title>Processes and Threads</title><link>/operating-system/processes-and-threads/</link><pubDate>Tue, 01 Sep 2020 13:14:09 +1000</pubDate><guid>/operating-system/processes-and-threads/</guid><description>Processes and Threads Processes and Threads A process (aka task / job) is an instance of a program A thread is a unit of execution of a process PID 8498 is the main process
PIDs 8499 and 8500 are the threads Process Control Block (PCB) The Process Control Block is a data structure which holds the information related to a process.
PID Registers Program Counter Stack Pointer Process State File Descriptors etc&amp;hellip; The kernel keeps track of all PCBs in a process table</description></item><item><title>The Operating System</title><link>/operating-system/overview/</link><pubDate>Tue, 01 Sep 2020 13:14:08 +1000</pubDate><guid>/operating-system/overview/</guid><description>Operating Systems The Role of the Operating System An Operating System can be seen in two ways
As a layer of abstraction (&amp;ldquo;Abstract Machine&amp;rdquo;) As a resource manager Abstract Machine The operating system extends the basic hardware set, adding new functionality that is usable by programs.
The OS hides the specifics and details of the hardware, and instead provides a unified interface to the system.
Resource Manager The operating system fairly allocates resources (memory, execution time, etc) to users and processes.</description></item><item><title>Waiting for Events</title><link>/cpu-fundamentals/waiting-for-events/</link><pubDate>Tue, 01 Sep 2020 13:13:57 +1000</pubDate><guid>/cpu-fundamentals/waiting-for-events/</guid><description>Waiting for Events Waiting for Events If a system requests for a resource, it will need to wait for that resource to become available before it can continue.
There are two methods to wait for resource availability - synchronous waiting (polling) and asynchronous waiting (interrupts)
Polling Every x time interval, the software will query the I/O device to see if it available.
Whilst no extra hardware is required (polling is software-based), it is not efficient due to wasted time checking for the I/O.</description></item><item><title>Example RE Disassembly</title><link>/cpu-fundamentals/example-re/</link><pubDate>Tue, 01 Sep 2020 13:13:56 +1000</pubDate><guid>/cpu-fundamentals/example-re/</guid><description> Disassembly #include &amp;lt;stdio.h&amp;gt; int main() { int a = 0xDEADBEEF; char b[] = &amp;quot;A\0&amp;quot;; unsigned int c = 0; while (c &amp;lt; 10) { puts(b); *b += 1; // A B C D E F G H I J c += 1; } } #include &amp;lt;stdio.h&amp;gt; int main() { int a = 0xDEADBEEF; char b[] = &amp;quot;A\0&amp;quot;; unsigned int c = 0; while (c &amp;lt; 10) { puts(b); *b += 1; // A B C D E F G H I J c += 1; } }</description></item><item><title>Execution</title><link>/cpu-fundamentals/execution/</link><pubDate>Tue, 01 Sep 2020 13:13:56 +1000</pubDate><guid>/cpu-fundamentals/execution/</guid><description>Execution CPU Speed The speed of a CPU is determined by its clock speed.
This speed refers to the rate (in Hz) at which the processor is able to generate pulses - that are used to synchronise its operations.
i.e. an Arduino (i.e. ATmega 328) operates at 16 MHz.
i.e. A Ryzen 9 3900X CPU operates at 3.8 GHz.
Execution In the CPU, there exists a Pointer Register known as the &amp;ldquo;program counter&amp;rdquo; (PC), which keeps track of the next instruction the processor should execute.</description></item><item><title>Compilers</title><link>/cpu-fundamentals/compilers/</link><pubDate>Tue, 01 Sep 2020 13:13:55 +1000</pubDate><guid>/cpu-fundamentals/compilers/</guid><description>Compilers The Language of the CPU As with all digital circuitry logic - the CPU only understands binary instructions.
We call these instructions &amp;ldquo;machine code&amp;rdquo;.
Machine code instructions are specific to the CPU architecture (Intel x86, amd64, MIPS, AVR, etc&amp;hellip;) and will only work for its intended architecture.
Modern day programming languages often have features like variables, macros and switch statements.
Whilst easy to understand by us humans, the computer itself won&amp;rsquo;t understand these things - which is why we have compilers.</description></item><item><title>Memory</title><link>/cpu-fundamentals/memory/</link><pubDate>Tue, 01 Sep 2020 13:13:33 +1000</pubDate><guid>/cpu-fundamentals/memory/</guid><description>Memory Everything is Memory When we save a file, it is saved to the computer memory.
When we perform an arithmetic operation, its operands and outputs are stored in the memory
When we press a key, a flag in the memory is changed.
When we launch a program, that program is loaded into memory!
Endian-ness Multi-byte values (i.e. values greater than 255) can be stored to the memory in two different ways.</description></item><item><title>Representation of Data</title><link>/cpu-fundamentals/representation-of-data/</link><pubDate>Tue, 01 Sep 2020 13:13:32 +1000</pubDate><guid>/cpu-fundamentals/representation-of-data/</guid><description>Representation of Data As digital circuits (i.e. computers) only deal with binary data (1s and 0s) - there exists different encoding schemas to represent different data types.
ASCII ASCII is a representation of the common characters used throughout the world (i.e the keys on your keyboard)
Positive Integers Positive integers are represented as their binary representation - bound to the data type assigned
i.e. the byte 81 == 0b01010001</description></item><item><title>The CPU</title><link>/cpu-fundamentals/overview/</link><pubDate>Tue, 01 Sep 2020 13:12:54 +1000</pubDate><guid>/cpu-fundamentals/overview/</guid><description>What&amp;rsquo;s in a CPU? Inside a CPU is a group of different microchips that collectively work together to serve the functionality of a CPU.
I/O To interact with other devices on the system, the CPU contains input and output lanes which are physically connected (via &amp;lsquo;busses&amp;rsquo; on the circuit board) to those devices.
I/O can include keyboards, mice, monitors, speakers.
Registers Registers are data storages that lie in the CPU.</description></item><item><title>Course Outline</title><link>/course-outline/</link><pubDate>Tue, 01 Sep 2020 12:38:30 +1000</pubDate><guid>/course-outline/</guid><description> System Internals Overview This course delves into the underlying low-level hardware components and software algorithms that form the base primitive components used in modern computing
Course goals To understand the layout of the computer memory, and the representation of data To understand the relationships and interactions between computer hardware, the operating system, and user code To learn fundamental structures and algorithms for storing and interacting with data Topics CPU Fundamentals Architectural layout of a CPU Representation of memory Memory allocation Program execution The Operating System Access Management Time Management Memory Management Resource Management Multiprocessors</description></item></channel></rss>